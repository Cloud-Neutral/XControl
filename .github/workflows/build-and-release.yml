name: Build Release Deploy

on:
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_action:
        description: "Deployment action to execute"
        type: choice
        options:
          - init
          - magrate
          - upgrade
          - backup
          - restore
          - destroy
        default: upgrade
      deploy_dry_run:
        description: "Run deployment steps in dry-run mode"
        type: boolean
        default: true

jobs:
  build-go:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        goos: [linux, windows, darwin]
        goarch: [amd64]
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.21
      - name: Build
        run: |
          mkdir -p build
          GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} go build -o build/xcontrol-server-${{ matrix.goos }}-${{ matrix.goarch }} ./cmd/xcontrol-server
          GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} go build -o build/xcontrol-cli-${{ matrix.goos }}-${{ matrix.goarch }} ./client
      - name: Upload server artifact
        uses: actions/upload-artifact@v4
        with:
          name: xcontrol-server-${{ matrix.goos }}-${{ matrix.goarch }}
          path: build/xcontrol-server-${{ matrix.goos }}-${{ matrix.goarch }}
      - name: Upload CLI artifact
        uses: actions/upload-artifact@v4
        with:
          name: xcontrol-cli-${{ matrix.goos }}-${{ matrix.goarch }}
          path: build/xcontrol-cli-${{ matrix.goos }}-${{ matrix.goarch }}

#  build-wasm:
#    runs-on: ubuntu-latest
#    steps:
#      - uses: actions/checkout@v4
#      - uses: actions-rs/toolchain@v1
#        with:
#          toolchain: stable
#          target: wasm32-wasip1
#          profile: minimal
#          override: true
#      - name: Build Wasm Module
#        run: make wasm-askai-limiter
#      - name: Upload artifact
#        uses: actions/upload-artifact@v4
#        with:
#          name: askai_limiter.wasm
#          path: build/askai_limiter.wasm

  release:
    runs-on: ubuntu-latest
    needs: [build-go] #, build-wasm
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          path: release-artifacts
          merge-multiple: true
      - name: Setup Node.js for static export
        if: github.ref == 'refs/heads/main'
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: yarn
          cache-dependency-path: ui/homepage/yarn.lock

      - name: Install homepage dependencies
        if: github.ref == 'refs/heads/main'
        working-directory: ui/homepage
        run: yarn install --frozen-lockfile

      - name: Run homepage export scripts
        if: github.ref == 'refs/heads/main'
        working-directory: ui/homepage
        run: yarn prebuild

      - name: Build homepage static bundle
        if: github.ref == 'refs/heads/main'
        working-directory: ui/homepage
        run: yarn build:static

      - name: Create homepage static archive
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          mkdir -p release-artifacts
          src="ui/homepage/out"
          if [[ ! -d "$src" ]]; then
            echo "Homepage static export directory not found" >&2
            exit 1
          fi
          tar -czf release-artifacts/homepage-static-export.tar.gz -C "$src" .

      - name: Upload homepage static bundle artifact
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: homepage-static-export
          path: ui/homepage/out

      - name: Prepare release assets
        run: |
          set -euo pipefail
          mkdir -p release-artifacts
          files=()
          if compgen -G "release-artifacts/xcontrol-*" > /dev/null; then
            while IFS= read -r file; do
              files+=("${file}")
            done < <(printf '%s\n' release-artifacts/xcontrol-*)
          fi
          if [[ -f "release-artifacts/homepage-static-export.tar.gz" ]]; then
            files+=("release-artifacts/homepage-static-export.tar.gz")
          fi
          if [[ ${#files[@]} -eq 0 ]]; then
            echo "No release assets were found" >&2
            exit 1
          fi
          {
            printf 'RELEASE_FILES<<EOF\n'
            printf '%s\n' "${files[@]}"
            printf 'EOF\n'
          } >> "$GITHUB_ENV"

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: daily-${{ github.run_number }}
          name: Daily Build ${{ github.run_number }}
          files: ${{ env.RELEASE_FILES }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  pre-setup:
    needs:
      - release
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        site: [global-homepage.svc.plus, cn-homepage.svc.plus]
    env:
      DEPLOY_ACTION: ${{ github.event.inputs.deploy_action || 'upgrade' }}
      DEPLOY_DRY_RUN: ${{ github.event.inputs.deploy_dry_run || 'true' }}
      ANSIBLE_USER: ${{ secrets.VPS_USER }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine deployment context
        run: |
          set -euo pipefail
          dry_run="${DEPLOY_DRY_RUN}"
          if [[ "${GITHUB_EVENT_NAME}" != "workflow_dispatch" ]]; then
            dry_run="true"
          fi
          echo "EFFECTIVE_DRY_RUN=${dry_run}" >> "$GITHUB_ENV"
          action="${DEPLOY_ACTION:-upgrade}"
          if [[ -z "${action}" ]]; then
            action="upgrade"
          fi
          echo "EFFECTIVE_DEPLOY_ACTION=${action}" >> "$GITHUB_ENV"


      - name: Download xcontrol server artifact
        uses: actions/download-artifact@v4
        with:
          name: xcontrol-server-linux-amd64
          path: artifacts/bin

      - name: Prepare server binary
        run: |
          set -euo pipefail
          install -d artifacts/bin
          mv artifacts/bin/xcontrol-server-linux-amd64 artifacts/bin/xcontrol-server
          chmod +x artifacts/bin/xcontrol-server

      - name: Download homepage static bundle
        uses: actions/download-artifact@v4
        with:
          name: homepage-static-export
          path: artifacts/homepage

      - name: Configure SSH access
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          install -m 700 -d ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${{ matrix.site }}" >> ~/.ssh/known_hosts

      - name: Ensure remote directories
        env:
          REMOTE_HOST: ${{ secrets.VPS_USER }}@${{ matrix.site }}
        run: |
          set -euo pipefail
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            ssh "$REMOTE_HOST" "echo '[DRY-RUN] would ensure /data/update-server/dashboard exists'"
          else
            ssh "$REMOTE_HOST" "sudo install -d -m 755 /data/update-server/dashboard"
          fi

      - name: Sync xcontrol server binary
        env:
          REMOTE_HOST: ${{ secrets.VPS_USER }}@${{ matrix.site }}
        run: |
          set -euo pipefail
          flags=("-avz")
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            flags+=("--dry-run")
          fi
          rsync "${flags[@]}" artifacts/bin/xcontrol-server "$REMOTE_HOST:/tmp/xcontrol-server"
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            ssh "$REMOTE_HOST" "echo '[DRY-RUN] would install /tmp/xcontrol-server to /usr/bin/xcontrol-server'"
          else
            ssh "$REMOTE_HOST" "sudo install -m 755 /tmp/xcontrol-server /usr/bin/xcontrol-server"
          fi

      - name: Sync homepage static export
        env:
          REMOTE_HOST: ${{ secrets.VPS_USER }}@${{ matrix.site }}
        run: |
          set -euo pipefail
          src=""
          # Attempt to extract any downloaded archive if the artifact was
          # delivered as a single zip file (the default behaviour of
          # actions/download-artifact@v4).
          shopt -s nullglob
          zip_candidates=(
            "artifacts/homepage/homepage-static-export.zip"
            "artifacts/homepage/homepage-static-export/homepage-static-export.zip"
            "artifacts/homepage/homepage-static-export/*.zip"
          )
          for archive in "${zip_candidates[@]}"; do
            for file in ${archive}; do
              if [[ -f "${file}" ]]; then
                dest_dir="${file%.zip}"
                mkdir -p "${dest_dir}"
                unzip -oq "${file}" -d "${dest_dir}"
              fi
            done
          done
          shopt -u nullglob

          candidates=(
            "artifacts/homepage/ui/homepage/out"
            "artifacts/homepage/out"
            "artifacts/homepage/homepage-static-export/ui/homepage/out"
            "artifacts/homepage/homepage-static-export/out"
            "artifacts/homepage/homepage-static-export/homepage-static-export/ui/homepage/out"
            "artifacts/homepage/homepage-static-export/homepage-static-export/out"
          )
          for candidate in "${candidates[@]}"; do
            if [[ -d "${candidate}" ]]; then
              src="${candidate}"
              break
            fi
          done
          if [[ -z "${src}" ]]; then
            # As a last resort, search for an "out" directory under artifacts/homepage
            mapfile -t found < <(find artifacts/homepage -mindepth 1 -maxdepth 5 -type d -name out 2>/dev/null | sort)
            if [[ ${#found[@]} -gt 0 ]]; then
              src="${found[0]}"
            fi
          fi
          if [[ -z "${src}" ]]; then
            echo "Static export directory not found under artifacts/homepage" >&2
            exit 1
          fi
          flags=("-avz" "--delete")
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            flags+=("--dry-run")
          fi
          rsync "${flags[@]}" "$src/" "$REMOTE_HOST:/data/update-server/dashboard/"

      - name: Stage manifest scripts on target
        env:
          REMOTE_HOST: ${{ secrets.VPS_USER }}@${{ matrix.site }}
        run: |
          set -euo pipefail
          remote_dir="/tmp/xcontrol-scripts"
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            ssh "$REMOTE_HOST" "echo '[DRY-RUN] would create ${remote_dir}'"
          else
            ssh "$REMOTE_HOST" "mkdir -p ${remote_dir}"
          fi
          flags=("-avz")
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            flags+=("--dry-run")
          fi
          rsync "${flags[@]}" scripts/gen_docs_manifest.py scripts/gen_mirror_manifest.py "$REMOTE_HOST:${remote_dir}/"
          if [[ "${EFFECTIVE_DRY_RUN}" != "true" ]]; then
            ssh "$REMOTE_HOST" "chmod +x ${remote_dir}/gen_docs_manifest.py ${remote_dir}/gen_mirror_manifest.py"
          fi
          echo "REMOTE_SCRIPT_DIR=${remote_dir}" >> "$GITHUB_ENV"

      - name: Generate docs manifest
        env:
          REMOTE_HOST: ${{ secrets.VPS_USER }}@${{ matrix.site }}
        run: |
          set -euo pipefail
          remote_dir="${REMOTE_SCRIPT_DIR:-/tmp/xcontrol-scripts}"
          cmd="python3 ${remote_dir}/gen_docs_manifest.py --root /data/update-server/docs"
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            ssh "$REMOTE_HOST" "echo '[DRY-RUN] would run ${cmd}'"
          else
            ssh "$REMOTE_HOST" "$cmd"
          fi

      - name: Generate download manifest
        env:
          REMOTE_HOST: ${{ secrets.VPS_USER }}@${{ matrix.site }}
        run: |
          set -euo pipefail
          remote_dir="${REMOTE_SCRIPT_DIR:-/tmp/xcontrol-scripts}"
          cmd="python3 ${remote_dir}/gen_mirror_manifest.py --root /data/update-server"
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            ssh "$REMOTE_HOST" "echo '[DRY-RUN] would run ${cmd}'"
          else
            ssh "$REMOTE_HOST" "$cmd"
          fi

  deploy:
    needs: pre-setup
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        site: [global-homepage.svc.plus, cn-homepage.svc.plus]
    env:
      DEPLOY_ACTION: ${{ github.event.inputs.deploy_action || 'upgrade' }}
      DEPLOY_DRY_RUN: ${{ github.event.inputs.deploy_dry_run || 'true' }}
      ANSIBLE_USER: ${{ secrets.VPS_USER }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine deployment context
        run: |
          set -euo pipefail
          dry_run="${DEPLOY_DRY_RUN}"
          if [[ "${GITHUB_EVENT_NAME}" != "workflow_dispatch" ]]; then
            dry_run="true"
          fi
          echo "EFFECTIVE_DRY_RUN=${dry_run}" >> "$GITHUB_ENV"
          action="${DEPLOY_ACTION:-upgrade}"
          if [[ -z "${action}" ]]; then
            action="upgrade"
          fi
          echo "EFFECTIVE_DEPLOY_ACTION=${action}" >> "$GITHUB_ENV"

      - name: Checkout infrastructure playbooks
        uses: actions/checkout@v4
        with:
          repository: svc-design/gitops
          path: gitops

      - name: Install Ansible
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install ansible

      - name: Configure SSH access
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          install -m 700 -d ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${{ matrix.site }}" >> ~/.ssh/known_hosts

      - name: Prepare provisioning inputs
        id: prepare_provisioning
        working-directory: gitops
        run: |
          set -euo pipefail
          cat <<EOF > playbooks/inventory.ini
          [targets]
          ${{ matrix.site }} ansible_user=${ANSIBLE_USER}
          EOF

          echo "inventory=playbooks/inventory.ini" >> "$GITHUB_OUTPUT"
          echo "skip=false" >> "$GITHUB_OUTPUT"

          extra_flags=()
          if [[ "${EFFECTIVE_DRY_RUN}" == "true" ]]; then
            extra_flags+=("--check")
          fi
          printf 'extra_flags=%s\n' "${extra_flags[*]}" >> "$GITHUB_OUTPUT"

          redis_playbook="playbooks/deploy_redis_vhosts.yml"
          if [[ ! -f "$redis_playbook" ]]; then
            echo "Required playbook ${redis_playbook} was not found" >&2
            exit 1
          fi
          echo "redis_playbook=${redis_playbook}" >> "$GITHUB_OUTPUT"

          postgres_playbook="playbooks/deploy_postgre_vhosts.yml"
          if [[ ! -f "$postgres_playbook" ]]; then
            if [[ -f "playbooks/deploy_postgres_vhosts.yml" ]]; then
              postgres_playbook="playbooks/deploy_postgres_vhosts.yml"
            else
              echo "Required playbook ${postgres_playbook} was not found" >&2
              exit 1
            fi
          fi
          echo "postgres_playbook=${postgres_playbook}" >> "$GITHUB_OUTPUT"

          openresty_playbook="playbooks/deploy_openresty_vhosts.yml"
          if [[ ! -f "$openresty_playbook" ]]; then
            echo "Required playbook ${openresty_playbook} was not found" >&2
            exit 1
          fi
          echo "openresty_playbook=${openresty_playbook}" >> "$GITHUB_OUTPUT"

          case "${EFFECTIVE_DEPLOY_ACTION}" in
            destroy|backup|backup-rollout|restore)
              echo "skip=true" >> "$GITHUB_OUTPUT"
              echo "Action ${EFFECTIVE_DEPLOY_ACTION} is not supported for homepage provisioning playbooks" >&2
              exit 0
              ;;
          esac

      - name: Provision Redis vhosts
        if: steps.prepare_provisioning.outputs.skip != 'true'
        working-directory: gitops
        env:
          INVENTORY: ${{ steps.prepare_provisioning.outputs.inventory }}
          EXTRA_FLAGS: ${{ steps.prepare_provisioning.outputs.extra_flags }}
          REDIS_PLAYBOOK: ${{ steps.prepare_provisioning.outputs.redis_playbook }}
        run: |
          set -euo pipefail
          flags=()
          if [[ -n "${EXTRA_FLAGS}" ]]; then
            flags+=(${EXTRA_FLAGS})
          fi
          ansible-playbook -i "${INVENTORY}" "${REDIS_PLAYBOOK}" "${flags[@]}" --limit "${{ matrix.site }}"

      - name: Provision PostgreSQL vhosts
        if: steps.prepare_provisioning.outputs.skip != 'true'
        working-directory: gitops
        env:
          INVENTORY: ${{ steps.prepare_provisioning.outputs.inventory }}
          EXTRA_FLAGS: ${{ steps.prepare_provisioning.outputs.extra_flags }}
          POSTGRES_PLAYBOOK: ${{ steps.prepare_provisioning.outputs.postgres_playbook }}
        run: |
          set -euo pipefail
          flags=()
          if [[ -n "${EXTRA_FLAGS}" ]]; then
            flags+=(${EXTRA_FLAGS})
          fi
          ansible-playbook -i "${INVENTORY}" "${POSTGRES_PLAYBOOK}" "${flags[@]}" --limit "${{ matrix.site }}"

      - name: Provision OpenResty vhosts
        if: steps.prepare_provisioning.outputs.skip != 'true'
        working-directory: gitops
        env:
          INVENTORY: ${{ steps.prepare_provisioning.outputs.inventory }}
          EXTRA_FLAGS: ${{ steps.prepare_provisioning.outputs.extra_flags }}
          OPENRESTY_PLAYBOOK: ${{ steps.prepare_provisioning.outputs.openresty_playbook }}
        run: |
          set -euo pipefail
          flags=()
          if [[ -n "${EXTRA_FLAGS}" ]]; then
            flags+=(${EXTRA_FLAGS})
          fi
          ansible-playbook -i "${INVENTORY}" "${OPENRESTY_PLAYBOOK}" "${flags[@]}" --limit "${{ matrix.site }}"